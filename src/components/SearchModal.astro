---
const filters = [
	{
		id: 'raw',
		name: 'Raw Materials',
	},

	{
		id: 'products',
		name: 'Products',
	},
	{
		id: 'cooking',
		name: 'Cooking',
	},
	{
		id: 'technology',
		name: 'Technology',
	},
	{
		id: 'buildings',
		name: 'Buildings',
	},
	{
		id: 'curiosities',
		name: 'Curiosities',
	},

	{
		id: 'other',
		name: 'Other',
	},
];
---

<div class="relative z-10 hidden" id="site-search" role="dialog" aria-modal="true">
	<div class="fixed inset-0 bg-gray-500 bg-opacity-75 transition-opacity"></div>

	<div id="site-search-modal" class="fixed inset-0 z-10 overflow-y-auto p-4 lg:pl-80 sm:p-6 md:p-20">
		<div class="mx-auto max-w-xl transform divide-y divide-gray-100 overflow-hidden rounded-xl bg-black shadow-2xl ring-1 ring-blue-500 ring-opacity-5 transition-all">
			<div class="relative">
				<svg class="pointer-events-none absolute top-3.5 left-4 h-5 w-5 text-white" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true">
					<path fill-rule="evenodd" d="M9 3.5a5.5 5.5 0 100 11 5.5 5.5 0 000-11zM2 9a7 7 0 1112.452 4.391l3.328 3.329a.75.75 0 11-1.06 1.06l-3.329-3.328A7 7 0 012 9z" clip-rule="evenodd"></path>
				</svg>

				<input id="search-input" type="text" class="h-12 w-full border-0 bg-transparent pl-11 pr-4 text-white placeholder-gray-400 focus:ring-0 sm:text-sm" placeholder="Search..." role="combobox" aria-expanded="false" aria-controls="options" aria-label="Search items" />
				<p class="text-sm px-4">Select Categories</p>
				<div class="flex flex-wrap gap-2 px-4 pb-4 pt-2">
					{
						filters.map((filter) => {
							return (
								<div class="inline-flex">
									<input type="checkbox" class="peer hidden" name="type-filter" id={filter.id} value={filter.name} tabindex="-1" />
									<label for={filter.id} class="select-none cursor-pointer rounded-lg border-2 border-blue-500 py-0 px-1.5 text-sm text-white transition-colors duration-200 ease-in-out peer-checked:bg-blue-500 peer-checked:text-black">
										{filter.name}
									</label>
								</div>
							);
						})
					}
				</div>
			</div>

			<div id="loading-indicator" class="hidden p-4 text-center text-white">
				Loading...
			</div>

			<div class="max-h-72 scroll-py-2 overflow-y-auto p-8 text-sm text-white" id="results" aria-live="polite"></div>
		</div>
	</div>
</div>

<script>
	interface SearchResult {
		name: string;
		type: string;
		url: string;
	}

	interface SearchResponse {
		body: SearchResult[];
	}

	type GroupedResults = Record<string, SearchResult[]>;

	const searchInput = document.getElementById('search-input') as HTMLInputElement | null;
	const typeCheckboxes = Array.from(document.querySelectorAll<HTMLInputElement>('input[name=type-filter]'));
	const resultsList = document.getElementById('results') as HTMLElement | null;
	const loadingIndicator = document.getElementById('loading-indicator') as HTMLElement | null;

	const searchCache = new Map<string, GroupedResults>();
	const MAX_CACHE_SIZE = 50; // Limit cache to prevent memory issues
	let debounceTimer: ReturnType<typeof setTimeout> | undefined;

	function groupBy(arr: SearchResult[], key: keyof SearchResult): GroupedResults {
		return arr.reduce((acc: GroupedResults, obj: SearchResult) => {
			const group = String(obj[key]);
			acc[group] = acc[group] || [];
			acc[group].push(obj);
			return acc;
		}, {});
	}

	async function performSearch(searchTerm: string, selectedTypes: string[]): Promise<void> {
		if (!loadingIndicator || !resultsList) return;

		// Check cache first before fetching
		if (searchCache.has(searchTerm)) {
			const cachedResults = searchCache.get(searchTerm);
			if (cachedResults) {
				displayResults(cachedResults, selectedTypes);
			}
			return;
		}

		loadingIndicator.classList.remove('hidden');

		try {
			const response = await fetch('/search.json');
			const results: SearchResponse = await response.json();
			const filteredResults = results.body.filter((result) => {
				if (!result || typeof result.name !== 'string') {
					return false;
				}
				return result.name.toLowerCase().includes(searchTerm);
			});
			const groupedResults = groupBy(filteredResults, 'type');

			// Limit cache size to prevent memory issues
			if (searchCache.size >= MAX_CACHE_SIZE) {
				const firstKey = searchCache.keys().next().value;
				if (firstKey) {
					searchCache.delete(firstKey);
				}
			}
			searchCache.set(searchTerm, groupedResults);
			displayResults(groupedResults, selectedTypes);
		} catch (error) {
			if (import.meta.env.DEV) {
				console.error('Error in performSearch:', error);
			}
			if (resultsList) {
				resultsList.innerHTML = '<p>Sorry, an error occurred while fetching results.</p>';
			}
		} finally {
			if (loadingIndicator) {
				loadingIndicator.classList.add('hidden');
			}
		}
	}

	function handleSearchInput(): void {
		if (!searchInput) return;

		const searchTerm = searchInput.value.trim().toLowerCase();
		const selectedTypes = typeCheckboxes
			.filter((checkbox) => checkbox.checked)
			.map((checkbox) => checkbox.value);

		if (debounceTimer) {
			clearTimeout(debounceTimer);
		}
		debounceTimer = setTimeout(() => performSearch(searchTerm, selectedTypes), 300);
	}

	function handleCheckboxChange(): void {
		handleSearchInput();
	}

	if (searchInput) {
		searchInput.addEventListener('input', handleSearchInput);
	}

	typeCheckboxes.forEach((checkbox) => {
		checkbox.addEventListener('change', handleCheckboxChange);
	});

	function displayResults(groupedResults: GroupedResults, selectedTypes: string[]): void {
		if (!resultsList) return;

		// Use DOM methods instead of innerHTML for better security
		resultsList.textContent = ''; // Clear existing content

		Object.keys(groupedResults).forEach((group) => {
			const filteredGroupResults = selectedTypes.length
				? groupedResults[group].filter((result) => selectedTypes.includes(result.type))
				: groupedResults[group];
			
			if (filteredGroupResults.length > 0) {
				const h3 = document.createElement('h3');
				h3.className = 'text-2xl';
				h3.textContent = group;
				resultsList.appendChild(h3);

				const ul = document.createElement('ul');
				ul.setAttribute('role', 'listbox');
				
				filteredGroupResults.forEach((result, index) => {
					const li = document.createElement('li');
					li.setAttribute('role', 'option');
					li.setAttribute('tabindex', '0');
					li.setAttribute('data-index', String(index));
					
					const a = document.createElement('a');
					a.href = result.url.replace(/\/+/g, '/');
					a.textContent = result.name;
					li.appendChild(a);
					ul.appendChild(li);
				});
				
				resultsList.appendChild(ul);
			}
		});

		setupKeyboardNavigation();
	}

	function setupKeyboardNavigation(): void {
		if (!searchInput || !resultsList) return;

		const resultItems = Array.from(resultsList.querySelectorAll<HTMLElement>('li[role="option"]'));
		resultItems.forEach((item, index) => {
			item.addEventListener('keydown', (e: KeyboardEvent) => {
				switch (e.key) {
					case 'ArrowDown':
						e.preventDefault();
						if (index < resultItems.length - 1) {
							resultItems[index + 1].focus();
						}
						break;
					case 'ArrowUp':
						e.preventDefault();
						if (index > 0) {
							resultItems[index - 1].focus();
						} else {
							searchInput.focus();
						}
						break;
					case 'Enter': {
						e.preventDefault();
						const link = item.querySelector<HTMLAnchorElement>('a');
						if (link) {
							link.click();
						}
						break;
					}
				}
			});
		});
	}
</script>